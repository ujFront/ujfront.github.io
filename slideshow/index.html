<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Drive Slideshow</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: white;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            height: 100vh;
        }

        #slideshow-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #media-display {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .slide-content {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.8s ease-in-out;
        }

        .slide-content.active {
            opacity: 1;
        }

        .slide-content img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .slide-content video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        #title-overlay {
            position: absolute;
            bottom: 120px;
            left: 50px;
            right: 50px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 30px;
            border-radius: 10px;
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
        }

        #title-overlay.show {
            opacity: 1;
            transform: translateY(0);
        }

        #description-overlay {
            position: absolute;
            bottom: 50px;
            left: 50px;
            right: 50px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.5rem;
            text-align: center;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
        }

        #description-overlay.show {
            opacity: 1;
            transform: translateY(0);
        }

        #error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(200, 0, 0, 0.9);
            padding: 40px;
            border-radius: 15px;
            font-size: 2rem;
            text-align: center;
            max-width: 80%;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            text-align: center;
        }

        .spinner {
            border: 4px solid #333;
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Leaderboard Styles */
        .leaderboard-container {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
            padding: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
        }

        .leaderboard-title {
            font-size: 4rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 40px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            color: white;
        }

        .leaderboard-content {
            display: flex;
            gap: 40px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .leaderboard-category {
            flex: 1;
            min-width: 500px;
            max-width: 600px;
        }

        .category-header {
            color: white;
            font-size: 2.2rem;
            font-weight: 700;
            padding: 20px 30px;
            text-align: left;
            margin-bottom: 8px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            border-radius: 12px 12px 0 0;
            background: linear-gradient(135deg, var(--header-color), rgba(0,0,0,0.2));
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .category-header .main-title {
            flex-grow: 1;
        }

        .category-header .bracket-info {
            font-size: 1.8rem;
            font-weight: 400;
            opacity: 0.8;
            margin-left: 20px;
            text-align: right;
            flex-shrink: 0;
        }

        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 0 0 12px 12px;
            overflow: hidden;
            box-shadow: 0 15px 35px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
        }

        .leaderboard-table td {
            padding: 10px 20px;
            font-size: 1.5rem;
            color: #2c3e50;
            border-bottom: 1px solid rgba(52, 73, 94, 0.1);
            transition: background-color 0.2s ease;
        }

        .leaderboard-table tr:nth-child(even) {
            background-color: rgba(236, 240, 241, 0.6);
        }

        .leaderboard-table tr:nth-child(odd) {
            background-color: rgba(255, 255, 255, 0.8);
        }

        .leaderboard-table tr:hover {
            background-color: rgba(52, 152, 219, 0.1);
        }

        .rank-cell {
            font-weight: 800;
            text-align: center;
            width: 80px;
            background: linear-gradient(135deg, #34495e, #2c3e50) !important;
            color: white !important;
            font-size: 1.6rem;
            position: relative;
        }

        .name-cell {
            font-weight: 600;
            font-size: 1.5rem;
        }

        .time-cell {
            text-align: right;
            font-family: 'SF Mono', 'Monaco', 'Courier New', monospace;
            font-weight: 700;
            font-size: 1.4rem;
            color: #e74c3c;
            min-width: 100px;
        }

        .leaderboard-background {
            position: absolute;
            right: -100px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0.1;
            width: 600px;
            height: 800px;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="30" r="15" fill="white"/><path d="M50 45 L35 85 L45 85 L45 70 L55 70 L55 85 L65 85 Z" fill="white"/></svg>') no-repeat center;
            background-size: contain;
        }
    </style>
</head>
<body>
    <div id="slideshow-container">
        <div id="media-display"></div>
        <div id="title-overlay"></div>
        <div id="description-overlay"></div>
    </div>

    <div id="loading">
        <div class="spinner"></div>
        <div>Loading slideshow...</div>
    </div>

    <div id="error-message" style="display:none;"></div>

    <script>
        class DriveSlideshow {
            constructor() {
                this.apiKey = null;
                this.folderId = null;
                this.config = {
                    default_duration: 10,
                    folder_title: "Slideshow",
                    leaderboard_sheet_id: null,
                    leaderboard_refresh: 300,
                    leaderboard_slides: []
                };
                this.slides = [];
                this.currentIndex = 0;
                this.isPlaying = false;
                this.currentTimeout = null;
                this.leaderboardCache = new Map();
                this.lastLeaderboardFetch = 0;
                this.liveLeaderboardData = null;
                this.liveDataLoadTime = 0;
            }

            async init() {
                // Get parameters from URL
                const urlParams = new URLSearchParams(window.location.search);
                this.folderId = urlParams.get('folder');
                this.apiKey = urlParams.get('key') || 'defaultkey'; // Default key - user should replace

                if (!this.folderId) {
                    this.showError('Missing folder parameter. Add ?folder=FOLDER_ID to the URL');
                    return;
                }

                try {
                    await this.loadFolder();
                    await this.loadLeaderboardData(); // Load leaderboard data once at startup
                    await this.startSlideshow();
                } catch (error) {
                    console.error('Initialization error:', error);
                    this.showError(error.message);
                }
            }

            async loadFolder() {
                try {
                    // First, try to load config
                    await this.loadConfig();
                    
                    // Then load all files
                    const response = await fetch(
                        `https://www.googleapis.com/drive/v3/files?q='${this.folderId}'+in+parents&key=${this.apiKey}&fields=files(id,name,mimeType,description,createdTime,modifiedTime,webContentLink,webViewLink,thumbnailLink)`
                    );
                    
                    if (!response.ok) {
                        if (response.status === 403) {
                            throw new Error('Access denied. Check if the folder is publicly accessible.');
                        }
                        throw new Error(`Failed to access folder: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (!data.files || data.files.length === 0) {
                        throw new Error('Folder is empty or contains no accessible files.');
                    }

                    // Process files and create slides
                    this.slides = await this.processFiles(data.files);
                    
                    if (this.slides.length === 0) {
                        throw new Error('No supported media files found in folder.');
                    }

                    // Sort alphabetically by filename
                    this.slides.sort((a, b) => a.filename.localeCompare(b.filename));

                } catch (error) {
                    throw new Error(`Error loading folder: ${error.message}`);
                }
            }

            async loadConfig() {
                // Look for settings.txt file in the Drive folder and use its description for config
                try {
                    console.log('Looking for settings.txt in folder:', this.folderId);
                    const response = await fetch(
                        `https://www.googleapis.com/drive/v3/files?q='${this.folderId}'+in+parents+and+(name='settings.txt'+or+name='config.txt')&key=${this.apiKey}&fields=files(id,name,description)`
                    );
                    
                    const data = await response.json();
                    
                    if (data.files && data.files.length > 0) {
                        const configFile = data.files[0];
                        console.log('Found config file:', configFile.name);
                        
                        if (configFile.description && configFile.description.trim()) {
                            console.log('Loading config from file description:', configFile.description);
                            this.parseDescriptionConfig(configFile.description);
                            console.log('Configuration loaded successfully:', this.config);
                            return;
                        } else {
                            console.log('Config file found but no description set');
                        }
                    } else {
                        console.log('No settings.txt or config.txt file found in folder');
                    }
                } catch (error) {
                    console.log('Error loading config from file descriptions:', error.message);
                }
                
                console.log('Using default configuration:', this.config);
            }

            async loadLeaderboardData() {
                // Load leaderboard data once at startup (shared across all leaderboard slides)
                try {
                    const dataUrl = 'https://script.google.com/macros/s/AKfycbwBLixPo5OGRVEraXVgdbe_Crndrt9KdypZVb13RZFM-ul6XLO4lR3npHk2FLf2tM0WQw/exec?json';
                    console.log('Loading live leaderboard data once at startup...');
                    
                    const response = await fetch(dataUrl);
                    const jsonData = await response.json();
                    
                    if (jsonData && jsonData.data) {
                        this.liveLeaderboardData = jsonData.data;
                        this.liveDataLoadTime = Date.now();
                        console.log('Live leaderboard data cached:', this.liveLeaderboardData.length, 'records');
                    } else {
                        console.warn('No leaderboard data returned from API');
                    }
                } catch (error) {
                    console.error('Failed to load leaderboard data:', error);
                    console.log('Leaderboard slides will use sample data');
                }
            }

            parseDescriptionConfig(description) {
                // Parse simple key: value format from file descriptions
                const lines = description.split('\n');
                
                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (!trimmedLine || trimmedLine.startsWith('#')) continue;
                    
                    if (trimmedLine.includes(':')) {
                        const [key, value] = trimmedLine.split(':').map(s => s.trim());
                        
                        switch (key.toLowerCase()) {
                            case 'default_duration':
                                this.config.default_duration = parseInt(value) || 10;
                                break;
                            case 'folder_title':
                                this.config.folder_title = value;
                                break;
                        }
                    }
                }
            }

            parseSheetConfig(values) {
                // Parse Google Sheet config: Column A = Setting Name, Column B = Value
                for (const row of values) {
                    if (row.length >= 2) {
                        const [key, value] = row;
                        
                        switch (key.toLowerCase().trim()) {
                            case 'default_duration':
                                this.config.default_duration = parseInt(value) || 10;
                                break;
                            case 'folder_title':
                                this.config.folder_title = value.toString().trim();
                                break;
                            case 'leaderboard_sheet_id':
                                this.config.leaderboard_sheet_id = value.toString().trim();
                                break;
                            case 'leaderboard_refresh':
                                this.config.leaderboard_refresh = parseInt(value) || 300;
                                break;
                        }
                    }
                }
            }

            parseConfig(configText) {
                const lines = configText.split('\n');
                let currentSection = null;
                let currentSlide = null;
                let currentCategory = null;

                for (let line of lines) {
                    line = line.trim();
                    if (line.startsWith('#')) continue;
                    if (!line) continue;

                    if (line.includes(':')) {
                        const [key, value] = line.split(':').map(s => s.trim());
                        
                        switch (key) {
                            case 'default_duration':
                                this.config.default_duration = parseInt(value);
                                break;
                            case 'folder_title':
                                this.config.folder_title = value.replace(/['"]/g, '');
                                break;
                            case 'leaderboard_sheet_id':
                                this.config.leaderboard_sheet_id = value.replace(/['"]/g, '');
                                break;
                            case 'leaderboard_refresh':
                                this.config.leaderboard_refresh = parseInt(value);
                                break;
                        }
                    }
                }
            }

            async processFiles(files) {
                const slides = [];
                
                for (const file of files) {
                    if (file.name === 'config.md' || file.name === 'settings.txt' || file.name === 'config.txt') continue;
                    
                    const fileType = this.getFileType(file);
                    
                    // For leaderboard files, store the raw description for later parsing
                    let title = null;
                    let description = null;
                    let duration = null;
                    
                    if (fileType === 'leaderboard') {
                        // For leaderboards, keep the full description for config parsing
                        description = file.description || '';
                        duration = this.parseFileDuration(file.name);
                    } else {
                        // For images/videos, parse title/description from description field
                        const parsed = this.parseDescriptionField(file.description || '');
                        title = parsed.title;
                        description = parsed.description;
                        duration = parsed.duration || this.parseFileDuration(file.name);
                    }
                    
                    const slide = {
                        id: file.id,
                        filename: file.name,
                        type: fileType,
                        mimeType: file.mimeType,
                        title: title,
                        description: description,
                        duration: duration,
                        url: this.getFileUrl(file),
                        thumbnailUrl: file.thumbnailLink
                    };
                    
                    console.log('Processing file:', file.name, 'Type:', slide.type, 'Duration:', slide.duration);
                    
                    if (slide.type !== 'unsupported') {
                        slides.push(slide);
                    } else {
                        console.log('Skipping unsupported file:', file.name, 'MIME:', file.mimeType);
                    }
                }
                
                console.log('Total slides created:', slides.length);
                return slides;
            }

            getFileType(file) {
                const name = file.name.toLowerCase();
                const mimeType = file.mimeType;
                
                // Detect leaderboard files by checking if filename contains "leaderboard"
                // This supports: "leaderboard_speed.md", "11 leaderboard kids.md", etc.
                if (name.includes('leaderboard') && name.endsWith('.md')) {
                    return 'leaderboard';
                }
                
                if (mimeType.startsWith('image/')) {
                    return 'image';
                }
                
                if (mimeType.startsWith('video/')) {
                    return 'video';
                }
                
                return 'unsupported';
            }

            parseFileDuration(filename) {
                const match = filename.match(/^\[(\d+)\]/);
                return match ? parseInt(match[1]) : this.config.default_duration;
            }

            parseDescriptionField(description) {
                if (!description || !description.trim()) {
                    return { title: null, description: null, duration: null };
                }

                let duration = null;
                let title = null;
                let lines = description.split('\n').map(line => line.trim()).filter(line => line);
                let contentLines = [];

                // Look for settings in description (title, duration, etc.)
                for (const line of lines) {
                    if (line.toLowerCase().startsWith('duration:')) {
                        const durationValue = line.split(':')[1];
                        if (durationValue) {
                            duration = parseInt(durationValue.trim()) || null;
                        }
                    } else if (line.toLowerCase().startsWith('title:')) {
                        const titleValue = line.split(':')[1];
                        if (titleValue) {
                            title = titleValue.trim();
                        }
                    } else if (!line.includes(':') || line.startsWith('#')) {
                        // Only include lines that aren't configuration settings
                        contentLines.push(line);
                    }
                }

                // If we found a title in the config, use it
                if (title) {
                    return { 
                        title: title, 
                        description: contentLines.length > 0 ? contentLines.join('\n') : null,
                        duration
                    };
                }

                // Otherwise, process remaining content as title/description
                if (contentLines.length === 0) {
                    return { title: null, description: null, duration };
                } else if (contentLines.length === 1) {
                    // If only one line, use it as description (no title)
                    return { title: null, description: contentLines[0], duration };
                } else {
                    // First line as title, rest as description
                    return { 
                        title: contentLines[0], 
                        description: contentLines.slice(1).join('\n'),
                        duration
                    };
                }
            }

            extractTitle(filename) {
                // Remove duration prefix [30] if present
                let title = filename.replace(/^\[\d+\]/, '');
                // Remove file extension
                title = title.replace(/\.[^.]+$/, '');
                // Replace underscores and dashes with spaces
                title = title.replace(/[_-]/g, ' ');
                // Capitalize first letter of each word
                title = title.replace(/\b\w/g, l => l.toUpperCase());
                return title.trim();
            }

            getFileUrl(file) {
                if (file.mimeType.startsWith('image/')) {
                    // Use thumbnail link for better CORS compatibility, fallback to direct link
                    return `https://drive.google.com/thumbnail?id=${file.id}&sz=w1920-h1080`;
                } else if (file.mimeType.startsWith('video/')) {
                    return `https://drive.google.com/file/d/${file.id}/preview`;
                }
                return file.webViewLink;
            }

            async startSlideshow() {
                document.getElementById('loading').style.display = 'none';
                this.isPlaying = true;
                await this.showSlide(0);
            }

            async showSlide(index) {
                if (index >= this.slides.length) {
                    index = 0; // Loop back to start
                }
                
                this.currentIndex = index;
                const slide = this.slides[index];
                
                console.log('Showing slide:', index, slide.filename, slide.type); // Debug log
                
                // Clear previous overlays
                this.clearOverlays();
                
                // Fade out current slide
                const currentSlide = document.querySelector('.slide-content.active');
                if (currentSlide) {
                    currentSlide.classList.remove('active');
                }
                
                // Wait for fade out
                await new Promise(resolve => setTimeout(resolve, currentSlide ? 400 : 0));
                
                // Clear all slide content
                const mediaDisplay = document.getElementById('media-display');
                mediaDisplay.innerHTML = '';
                
                try {
                    switch (slide.type) {
                        case 'image':
                            await this.showImage(slide);
                            break;
                        case 'video':
                            await this.showVideo(slide);
                            break;
                        case 'leaderboard':
                            await this.showLeaderboard(slide);
                            break;
                    }
                    
                    // Show metadata with delay for smooth appearance
                    setTimeout(() => this.showMetadata(slide), 600);
                    
                } catch (error) {
                    console.error('Error showing slide:', error);
                    this.showError(`Error loading ${slide.filename}: ${error.message}`);
                    // Skip to next slide after 3 seconds
                    setTimeout(() => this.nextSlide(), 3000);
                }
            }

            async showImage(slide) {
                const slideWrapper = document.createElement('div');
                slideWrapper.className = 'slide-content';
                
                const img = document.createElement('img');
                
                return new Promise((resolve, reject) => {
                    img.onload = () => {
                        slideWrapper.appendChild(img);
                        document.getElementById('media-display').appendChild(slideWrapper);
                        
                        // Fade in the slide
                        setTimeout(() => slideWrapper.classList.add('active'), 50);
                        
                        // Schedule next slide
                        this.currentTimeout = setTimeout(() => this.nextSlide(), slide.duration * 1000);
                        resolve();
                    };
                    
                    img.onerror = (error) => {
                        // Try fallback URL format
                        const fallbackUrl = `https://drive.google.com/uc?id=${slide.id}&export=download`;
                        
                        const fallbackImg = document.createElement('img');
                        fallbackImg.onload = () => {
                            slideWrapper.appendChild(fallbackImg);
                            document.getElementById('media-display').appendChild(slideWrapper);
                            setTimeout(() => slideWrapper.classList.add('active'), 50);
                            this.currentTimeout = setTimeout(() => this.nextSlide(), slide.duration * 1000);
                            resolve();
                        };
                        
                        fallbackImg.onerror = () => {
                            reject(new Error('Failed to load image with both URLs'));
                        };
                        
                        fallbackImg.src = fallbackUrl;
                    };
                    
                    img.src = slide.url;
                });
            }

            async showVideo(slide) {
                const slideWrapper = document.createElement('div');
                slideWrapper.className = 'slide-content';
                
                const video = document.createElement('video');
                video.controls = false;
                video.autoplay = true;
                video.muted = false;
                
                return new Promise((resolve, reject) => {
                    video.onloadeddata = () => {
                        slideWrapper.appendChild(video);
                        document.getElementById('media-display').appendChild(slideWrapper);
                        
                        // Fade in the slide
                        setTimeout(() => slideWrapper.classList.add('active'), 50);
                        resolve();
                    };
                    
                    video.onended = () => {
                        this.nextSlide();
                    };
                    
                    video.onerror = () => {
                        reject(new Error('Failed to load video'));
                    };
                    
                    video.src = slide.url;
                });
            }

            async showLeaderboard(slide) {
                // Extract leaderboard type from filename - handle various formats
                // Examples: "leaderboard_speed.md", "11 [15] leaderboard kids.md", "05 leaderboard_rainbow.md"
                let leaderboardType = this.extractLeaderboardType(slide.filename);
                
                console.log('Showing leaderboard:', slide.filename, 'Type:', leaderboardType); // Debug log
                console.log('Slide description for config:', slide.description); // Debug log
                
                const slideWrapper = document.createElement('div');
                slideWrapper.className = 'slide-content';
                
                // Parse leaderboard config from file description
                const leaderboardConfig = this.parseLeaderboardConfig(slide.description);
                console.log('Parsed leaderboard config:', leaderboardConfig); // Debug log
                
                const leaderboardHtml = await this.generateLeaderboard(leaderboardType, leaderboardConfig);
                slideWrapper.innerHTML = leaderboardHtml;
                
                document.getElementById('media-display').appendChild(slideWrapper);
                
                // Fade in the slide
                setTimeout(() => slideWrapper.classList.add('active'), 50);
                
                // Schedule next slide
                this.currentTimeout = setTimeout(() => this.nextSlide(), slide.duration * 1000);
            }

            extractLeaderboardType(filename) {
                // Handle various leaderboard filename formats:
                // "leaderboard_speed.md" -> "speed"
                // "11 [15] leaderboard kids.md" -> "kids"  
                // "05 leaderboard_rainbow.md" -> "rainbow"
                
                let name = filename;
                
                // Remove file extension
                name = name.replace(/\.[^.]+$/, '');
                
                // Remove duration prefix like [15]
                name = name.replace(/^\d*\s*\[\d+\]\s*/, '');
                
                // Remove number prefix like "11 "
                name = name.replace(/^\d+\s+/, '');
                
                // Handle "leaderboard_type" format
                if (name.includes('leaderboard_')) {
                    return name.replace(/.*leaderboard_/, '');
                }
                
                // Handle "leaderboard type" format (space separated)
                if (name.toLowerCase().startsWith('leaderboard ')) {
                    return name.replace(/^leaderboard\s+/i, '');
                }
                
                // Fallback - return the cleaned name
                return name.replace(/leaderboard/gi, '').trim() || 'default';
            }

            parseLeaderboardConfig(description) {
                // Parse leaderboard configuration from file description
                if (!description || !description.trim()) {
                    return null; // Use default/sample data
                }

                const config = {
                    title: '',
                    route_type: 'Official Speed',
                    limit: 12,
                    data_url: 'https://script.google.com/macros/s/AKfycbwBLixPo5OGRVEraXVgdbe_Crndrt9KdypZVb13RZFM-ul6XLO4lR3npHk2FLf2tM0WQw/exec?json',
                    tables: []
                };

                const lines = description.split('\n');
                let currentTable = null;

                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (!trimmedLine || trimmedLine.startsWith('#')) continue;

                    if (trimmedLine.includes(':')) {
                        const [key, value] = trimmedLine.split(':').map(s => s.trim());

                        switch (key.toLowerCase()) {
                            case 'title':
                                config.title = value;
                                break;
                            case 'route_type':
                                config.route_type = value;
                                break;
                            case 'limit':
                                config.limit = parseInt(value) || 12;
                                break;
                            case 'data_url':
                                config.data_url = value;
                                break;
                            case 'table':
                                // New table definition
                                currentTable = {
                                    name: value,
                                    gender: '',  // Empty means all genders
                                    category: 'open',
                                    color: '#cc0000',
                                    limit: null  // Per-table limit (will use global if not set)
                                };
                                config.tables.push(currentTable);
                                break;
                            case 'gender':
                                if (currentTable) currentTable.gender = value;
                                break;
                            case 'category':
                                if (currentTable) currentTable.category = value.toLowerCase();
                                break;
                            case 'color':
                                if (currentTable) currentTable.color = value;
                                break;
                            case 'limit':
                                if (currentTable) {
                                    // Per-table limit
                                    currentTable.limit = parseInt(value) || 12;
                                } else {
                                    // Global limit
                                    config.limit = parseInt(value) || 12;
                                }
                                break;
                        }
                    }
                }

                return config.tables.length > 0 ? config : null;
            }

            async processLiveData(rawData, config) {
                // Process and filter live data according to config
                const categories = [];
                
                for (const table of config.tables) {
                    // Filter data for this table
                    let filteredData = rawData.filter(record => {
                        // Filter by route type (from config)
                        if (config.route_type && record.Route !== config.route_type) {
                            return false;
                        }
                        
                        // Filter by gender (from table config)
                        if (table.gender && record.Gender !== table.gender) {
                            return false;
                        }
                        
                        // Filter by category (from table config)
                        if (table.category !== 'open' && record.category !== table.category) {
                            return false;
                        }
                        
                        return true;
                    });
                    
                    // Sort by time (ascending - fastest first)
                    filteredData.sort((a, b) => {
                        const timeA = parseFloat(a.Time) || 999999;
                        const timeB = parseFloat(b.Time) || 999999;
                        return timeA - timeB;
                    });
                    
                    // Limit to top N results - use per-table limit if set, otherwise global limit
                    const tableLimit = table.limit || config.limit || 12;
                    filteredData = filteredData.slice(0, tableLimit);
                    
                    // Format for display
                    const formattedData = filteredData.map((record, index) => ({
                        rank: index + 1,
                        name: record.Name,
                        time: record.Time
                    }));
                    
                    categories.push({
                        name: table.name,
                        color: table.color,
                        data: formattedData
                    });
                }
                
                return categories;
            }

            async generateLeaderboard(type, config = null) {
                // Use config from file description if available, otherwise use sample data
                let leaderboardData;
                
                if (config) {
                    // Use cached live data if available
                    if (this.liveLeaderboardData) {
                        console.log('Using cached leaderboard data (' + this.liveLeaderboardData.length + ' records)');
                        
                        leaderboardData = {
                            title: config.title || `${type.charAt(0).toUpperCase() + type.slice(1)} Leaderboard`,
                            categories: await this.processLiveData(this.liveLeaderboardData, config)
                        };
                    } else {
                        console.log('No cached data available, using sample data');
                        
                        // Fallback to sample data structure with config
                        leaderboardData = {
                            title: config.title || `${type.charAt(0).toUpperCase() + type.slice(1)} Leaderboard`,
                            categories: config.tables.map(table => ({
                                name: table.name,
                                color: table.color,
                                data: [
                                    { rank: 1, name: "Competitor 1", time: "5.123" },
                                    { rank: 2, name: "Competitor 2", time: "5.456" },
                                    { rank: 3, name: "Competitor 3", time: "5.789" }
                                ]
                            }))
                        };
                    }
                } else {
                    // Sample leaderboard data (fallback when no config is provided)
                    const sampleData = {
                        speed: {
                            title: "Speed Leaderboard",
                            categories: [
                                {
                                    name: "Male Youth 13-18 yo",
                                    color: "#cc0000",
                                    data: [
                                        { rank: 1, name: "Max Botica", time: "4.690" },
                                        { rank: 2, name: "James Mouton", time: "5.113" },
                                        { rank: 3, name: "Alfie Wall", time: "6.384" },
                                        { rank: 4, name: "Ronan Finlay", time: "6.646" },
                                        { rank: 5, name: "Kristopher Moretti", time: "6.768" }
                                    ]
                                },
                                {
                                    name: "Female Youth 13-18 yo",
                                    color: "#cc0000", 
                                    data: [
                                        { rank: 1, name: "Christel Kotze", time: "9.930" },
                                        { rank: 2, name: "Olivia Hawryluk", time: "10.070" },
                                        { rank: 3, name: "Jaiya Marns-morris", time: "10.092" },
                                        { rank: 4, name: "Catherine Mirasol", time: "10.971" },
                                        { rank: 5, name: "Audrey Minaee", time: "11.978" }
                                    ]
                                }
                            ]
                        }
                    };

                    leaderboardData = sampleData[type] || sampleData.speed;
                }
                
                let html = `
                    <div class="leaderboard-container">
                        <div class="leaderboard-background"></div>
                        <h1 class="leaderboard-title">${leaderboardData.title}</h1>
                        <div class="leaderboard-content">
                `;
                
                for (const category of leaderboardData.categories) {
                    // Parse title and bracket info (e.g., "Male Youth (13-18yo)")
                    const titleParts = category.name.match(/^(.+?)(\s*\([^)]+\))?$/);
                    const mainTitle = titleParts ? titleParts[1].trim() : category.name;
                    const bracketInfo = titleParts && titleParts[2] ? titleParts[2].trim() : '';
                    
                    html += `
                        <div class="leaderboard-category">
                            <div class="category-header" style="--header-color: ${category.color}; background: linear-gradient(135deg, ${category.color}, rgba(0,0,0,0.2));">
                                <span class="main-title">${mainTitle}</span>
                                ${bracketInfo ? `<span class="bracket-info">${bracketInfo}</span>` : ''}
                            </div>
                            <table class="leaderboard-table">
                    `;
                    
                    for (const entry of category.data) {
                        html += `
                            <tr>
                                <td class="rank-cell">${entry.rank}</td>
                                <td class="name-cell">${entry.name}</td>
                                <td class="time-cell">${entry.time}</td>
                            </tr>
                        `;
                    }
                    
                    html += `
                            </table>
                        </div>
                    `;
                }
                
                html += `
                        </div>
                    </div>
                `;
                
                return html;
            }

            showMetadata(slide) {
                const titleEl = document.getElementById('title-overlay');
                const descEl = document.getElementById('description-overlay');
                
                // Show title if parsed from description field
                if (slide.title && slide.title.trim() && slide.type !== 'leaderboard') {
                    titleEl.textContent = slide.title;
                    setTimeout(() => titleEl.classList.add('show'), 100);
                } else {
                    titleEl.classList.remove('show');
                }
                
                // Show description if parsed from description field
                if (slide.description && slide.description.trim() && slide.type !== 'leaderboard') {
                    descEl.textContent = slide.description;
                    setTimeout(() => descEl.classList.add('show'), 200);
                } else {
                    descEl.classList.remove('show');
                }
            }

            clearOverlays() {
                document.getElementById('title-overlay').classList.remove('show');
                document.getElementById('description-overlay').classList.remove('show');
            }

            nextSlide() {
                if (this.currentTimeout) {
                    clearTimeout(this.currentTimeout);
                }
                this.showSlide(this.currentIndex + 1);
            }

            showError(message) {
                document.getElementById('loading').style.display = 'none';
                const errorEl = document.getElementById('error-message');
                errorEl.textContent = message;
                errorEl.style.display = 'block';
            }
        }

        // Initialize slideshow when page loads
        window.addEventListener('load', () => {
            const slideshow = new DriveSlideshow();
            slideshow.init();
        });

        // Handle keyboard controls
        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowRight':
                case ' ':
                    // Next slide
                    if (window.slideshow) {
                        window.slideshow.nextSlide();
                    }
                    break;
                case 'Escape':
                    // Exit fullscreen
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                    break;
            }
        });
    </script>
</body>
</html>